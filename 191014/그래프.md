# 그래프

## 1. 그래프 기본

## 2. 그래프 탐색

## 3. 서로소 집합들

- 연결리스트
- 트리 형태로 표현(주로 사용함 -> 부모정보를 저장하는 트리 형태임...)
- Make-Set(x) : x를 가지는 집합 만들기
- Find-Set(x) : 원소 x가 속한 집합의 식별값(대표값)을 리턴 -> 부모를 따라서 루트까지 간다..
- Union(x, y) : x, y가 속한 집합을 합쳐서 하나의 집합으로 리턴

### 상호배타 집합 표현 - 트리

- 자식노드가 부모 노드를 가리키도록 표현
- 루트가 대표자가 됨(루트는 자기 자신을 가리키게 한다.)
- 두 집합을 합칠때는 한쪽 루트의 부모를 다른쪽 루트의 부모를 가리키게 한다

### 상호배타 집합 연산

- rank를 이용한 union
  - 각 노드는 자신을 루트로 하는 subtree의 높이를 rank로 저장
  - 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다
  -  
- find-set연산
  - 루트일 경우 리턴해서 루트 가리키게한다..
- union 연산
  - x의 루트 찾고 y가 속한 루트 찾기..
  - link(x, y)의 x, y는 루트임...
  - 루트 x, y의 랭크값 비교해서 작은 애를 큰 애 밑으로 붙이기

```python
# 창용마을 무리의 개수
# disjoint-sets
```



## 4. 최소신장트리

- 트리를 만들기위한(모든 정점연결) 최소한의 간선만 남긴다. -> 최소신장트리
- 최소신장트리는 여러 개 있을 수 있다.

### KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 최소신장트리를 찾는 알고리즘
  - 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
  - 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴(사이클이 존재(disjoint-set이용해 판단)하면 다음으로 가중치가 낮은 간선 선택)
  - n-1 개의 간선이 될 때(모든 정점이 연결됨)까지 위의 과정을 반복...

### Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 mst를 만들어 가는 방식
  - 임의 정점을 하나 선택해서 시작
  - 선택한 정점들과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
  - 모든 정점이 선택될 때 까지 위의 과정 반복
- 서로소인 2개의 집합 정보를 유지
  - 트리정점들 - mst를 만들기 위해 선택된 정점들
  - 비트리 정점들 - 선택 되지 않은 정점들

## 5. 최단경로

- 최단경로
  - 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점까지의 최단 경로
  - 다익스트라(Dijkstra) 알고리즘
    - 음의 가중치를 허용하지 않는다.
  - 벨만 포드 알고리즘
    - 음의 가중치 허용
    - 사이클이 있는 그래프에서 가중치 경로의 합이 음수가 되는 경우 제대로 동작하지 않음..

- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬 알고리즘

### Dijkstra 알고리즘

- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
- 시작정점(s)에서 끝정점(t)까지의 최단 경로에정점 x가 존재한다. 이때, 최단경로는 s에서 x까지의 최단경로와 x에서 t까지의 최단경로로 구성된다.
- 탐욕 기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사하다.
- 최단경로의 최적부분 구조
  - s -> t까지의 최단경로(최적해)를 찾았다고 가정.(s->t 거쳐가는 정점 중 x가 존재.)
  - s->x->t에서 s->x도 최단경로일 수 밖에 없다.