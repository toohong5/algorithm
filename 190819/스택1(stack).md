# 스택1(stack)

## 1. 스택

### 1) 스택의 구현

- 후입선출_LIFO(Last In First Out) : 역순으로 꺼낸다.
- 선형구조를 갖는다. (자료간의 관계가 1:1 관계를 갖는다. <->비선형구조(트리, 그래프))
- top : 마지막에 삽입된 원소의 위치
- push : 자료를 집어넣는 연산(push)
- pop: 꺼내는 연산(pop)
- isEmpty : 스택이 공백인지 아닌지를 확인하는 연산
- peek : 스택의 top에 있는 원소를 반환하는 연산
- 빈 공간을 미리 만들어 두고 0번 인덱스 부터 채워넣는다.

```python
# C-style
S = [0] * 3 # 저장소
top = -1 # 마지막에 저장된 자료의 인덱스

def push(item):
    global top
    # full 상태를 체크 해야함
    if top == 2: return f'full'
    
    top += 1
    S[top] = item
def pop():
    global top
    # empty 상태 체크
    if top == -1: return f'empty'
    ret = S[top]
    top -= 1
    return ret
# 저장소보다 많은 수를 입력하게 되면 에러남
for i in range(3):
    push(i) # 0, 1, 2입력됨
    
print(pop()) # 2
print(pop()) # 1
print(pop()) # 0 으로 나옴

#----------------------------------------------------

# python - style
S = []
def push(item):
    # full 상태를 체크할 필요 없음(저장소에 max 없음)
    S.append(item)
def pop():
    # empty 상태를 체크필요함!!!!
    """
    if len(S) == 0:
        print('empty')
        return
    """
    return S.pop()
    
# empty 상태 체크하는 함수
def isEmpty():
    return len(S) == 0

for i in range(3):
    push(i) # 0, 1, 2입력됨
    
# 빈상태인지 아닌지 체크 필수임!!!!    
# 비어있지 않으면 계속 꺼내옴!!!    
while not isEmpty():
    print(pop())

```

```python
from collections import deque
import time
start = time.time()
# deque이용시 실행시간 더 빠름.
S = deque()
N = 1000000
for i in range(N):
	S.append(i)
while S: # 비면 False가 됨..
    S.popleft() # 들어간 순서대로 나온다.(처음 들어간거 먼저 뺌)
    S.pop() # 마지막에 들어간 것 부터 꺼낸다.
```

### 2) 스택의 응용

```python
# 괄호검사

# 포함관계 : 가운데를 기준으로 역순으로 출력시 짝이 맞아야한다.
# 하나씩 살펴보면서 괄호만 체크
# 처음부터 하나씩 읽으면서 여는 괄호 나오면 기록(삽입), 닫는괄호 만나면 스택에 가장 마지막에 들어간 괄호(top)와 같은 종류여야 함. 
# => 여는괄호 순서대로 집어넣고 닫는괄호 만나면 역순으로 꺼내서 비교함.
# empty 가 되면 잘못된 것
# 꺼냈는데 괄호 종류가 다르면 잘못 된 것
# 스택에 아무것도 없어야함(남아있다면 닫는괄호가 부족하다는 의미)
# 틀린거 하나라도 있으면 끝냄
```

- fuction call
- 

## 2. 재귀호출

```python
# 문제를 재귀적으로 푼다,
# 재귀적 정의를 구현할 때 재귀호출이 좋다.
# 재귀적 정의 --> 좀 더 작은 문제의 답을 사용해서 더 큰 문제의 답을 구하는 방법
# 팩토리얼 구하는 문제
# 문제의 크기는 자연수로 표현

def factorial(n): # 매개변수 - 문제의 크기를 나타내는 값
    			  # 반환값 - n!의 값(문제의 해)
    if n == 0 or n == 1: # 기저 사례
        # 재귀호출 하지 않고 종료
        return 1
    else:
        # 재귀호출
        return factorial(n - 1) * n

# 재귀함수 호출 할 때마다 매개변수 생김.

# 피보나치 수열 _ 2**n만큼 시간복잡도 늘어남 -> 엄청난 중복호출이 존재함... -> 메모이제이션으로 실행속도 빠르게 할 수 있음
def fibonacci(n): # n번째 피보나치 수를 반환
    if n==1 or n==0:
        return n
   	return fibonacci(n - 1) + fibonacci(n - 2)

fibonacci(7)
-> fibo(6) + fibo(5)
->6 부르고 잠시 멈춤
->fibo(6)을 실행
->fibo(5) + fibo(4) 에서 fibo(5) 먼저 실행
->
```



## 3. Memoization

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술.

  ```python
  memo = [-1] * 100 # 아직 할당되지 않으면 -1
  
  def fibonacci(n):
      if n == 1 or n == 0:
          return n
      # 이미 답을 구했는지 확인
      if memo[n] != -1:
          return memo[n]
      # memo에 값을 저장해놓음(같은 값을 매개변수를 호출하면 바로 값 반환해줌)
      memo[n] = fibonacci(n - 1) + fibonacci(n - 2)
      return memo[n]
  
  ```

  

## 4. DP(동적계획)

- 최적화문제를 해결하는 알고리즘

- 문제의 크기가 작은 부분 문제들을 모두 해결 한 후에 그 해들을 이용해 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘.

- 앞의 작은 문제들이 해결되어야 뒤의 큰 문제들 해결 가능함..

  ```python
  # 재귀호출 + 메모이제이션
  memo = [-1] * 100
  def fibonacci(n):
      memo[0], memo[1] = 0, 1
      for i in range(2, n + 1): # i=>문제를 나타내는 값
          memo[i] = memo[i - 1] + memo[i - 2]
      return memo[n]
  ```

- 좀 더 작은문제의 답을 이용해 큰 문제의 답을 찾아가는 방법



## 5. DFS(깊이우선탐색)**

### 1) 그래프(그래프 구분!!!)

- 무향그래프 : 친구관계(쌍방향), 두 정점사이의 동등한 관계
- 유향그래프 : 동등하지 않은 관계

- 경로 : 간선들을 순서대로 나열한 것
  - 단순경로 : 정점을 최대 한 번만 지나는 경로
  - 사이클 : 시작한 정점에서 끝나는 경로

### 2) 그래프의 표현

- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 유향그래프는 간선의 개수만큼 표시, 진출(정점에서 나가는 간선)과 진입(정점으로 들어오는 간선)이 있음.
- 무향그래프는 쌍방향임.



### 3) DFS 알고리즘

- 그래프의 모든 인접정점을 읽는다.

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법

- 스택사용

  1. 시작정점 v를 결정하여 방문

  2. 방문한 정점인지 아닌지에 대한 정보 필요(방문했으면 1 아니면 0 으로 저장...)

  3. 정점 v에 인접한 정점중에서..방문하지 않은 정점 w가 있으면 v를 스택에 저장하고 w방문->반복 / 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 반복
  4. 스택이 공백이 될때까지 반복




## 6. 위상정렬

- DAG그래프 (사이클 없는 유향그래프)
  1. 진입 차수 계산 0 인 애들 찾아서 쓰고 인접정점들 -1씩 해줌