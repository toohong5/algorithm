# 완전 검색 & 그리디

## 1. 반복과 재귀

- for -> 반복횟수를 알 때

- while -> 반복 횟수를 모르고 상태를 기준으로 반복할지 말지 정함.

- 재귀 -> 문제의 크기를 줄이면서 더 이상 줄일 필요가 없는 문제의 답을 이용해 큰 문제의 답을 구하는 방법

  - 동적계획법(DP) / 분할정복 -> 큰문제와 작은문제간의 관계

  - 탐색 -> 그래프 깊이우선 탐색(DFS), 트리 순회 / 백트래킹(상태공간 트리, 그래프 탐색)

    

## 2. 완전검색 기법 -> 최적화문제

- 조합적 문제에 대한 BRUTE-FORCE방법

### 

## 3. 조합적 문제 -> 백트래킹

- 순열

  ```python
  # 중복순열
  arr = 'abc'
  n = len(arr)
  for i in range(n):
      for j in range(n):
          for k in range(n):
              print(arr[i], arr[j], arr[k])
  
  # 순열
  arr = 'abc'
  n = len(arr)
  for i in range(n):
      for j in range(n):
          if j == i: continue
          for k in range(n):
              if k==i or k == j: continue
              print(arr[i], arr[j], arr[k])
              
  # 재귀
  def perm(k):
      if k == n:
          print(arr)
      else:
          for i in range(k, n):
              arr[k], arr[i] = arr[i], arr[k] # 1번 위치 기준으로 자리바꿔감..
              perm(k + 1)
              arr[k], arr[i] = arr[i], arr[k]
  
  arr = [1, 2, 3, 4]
  n = len(arr)
  ```

- 조합

  ```python
  # 조합
  arr = 'abcde'
  n = len(arr)
  for i in range(n):
      for j in range(i + 1, n): # 첫번째꺼 다음것 부터!!
          for k in range(j + 1, n):
              print(arr[i], arr[j], arr[k])
  
  # 중복조합(nHr)
  arr = 'abcde'
  n = len(arr)
  for i in range(n):
      for j in range(i, n): # 첫번째꺼 다음것 부터!!
          for k in range(j, n):
              print(arr[i], arr[j], arr[k])
  # 재귀
  def nCr(n, r):
      if n == r or r == 0: return 1
      else:
          return nCr(n-1, r-1) + nCr(n-1, r)
       # n개의 원소 중 r개를 뽑는데 특정원소 하나를 포함시킨 경우와 포함시키지 않은 경우를 더한다.
  print(nCr(5, 3))
  ```

  

## 4. 탐욕 알고리즘

- 회의실 시간 문제
  - 완전탐색 -> 부분집합 구해서 겹치는게 있으면 빼기..
  - 탐욕 -> 어떤 값을 기준으로 오름차순(내림차순)으로 정렬 후 하나씩 답을 골라간다...
  - 