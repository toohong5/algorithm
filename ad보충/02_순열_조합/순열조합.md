# 순열/조합 생성 <-- 백트래킹 이해

## 순열/조합 생성 방법 -> 재귀호출

##  		-- > 상태공간트리 --> 재귀 함수 호출 트리

## 		-- > 선택의 과정

## 1. 재귀함수 호출 트리

``` python
# 원소의 개수만큼 만든다
path = [0] * 3
def subset(k, n):	# n: 
    if k == n: # 마지막 단계
        return
    # 함수 호출이 선택이다.
    path[k] = 1; subset(k + 1, n) # 선택했을 때
    path[k] = 0;subset(k + 1, n)  # 선택 안했을 때
subset(0, 3)


# 원소의 개수 n개인 집합의 전체 부분집합 구하기...
# n번의 선택을 통해 부분집합 생성, 각각의 원소에 대해서 선택..(부분집합에 넣을지 말지...)
# 매번 선택할 때의 선택지 ==> 2개

```



## 2. 순열(순서0)

- 모든 순열을 생성하는 과정을 선택의 과정으로 생각하고 트리를 따라가듯이 선택해간다  생각..

- n! : 순열의 개수(n: 원소의 개수)

  ```python
  N = 3 #(0, 1, 2)
  # 중복 순열
  for i in range(N):
      for j in range(N):
          for k in range(N):
              print(i, j, k)
  # 순열
  visit = [0] * 3 # 이전단계에서 선택한것을 표시함
  for i in range(N):
      if visit[i]:continue
      visit[i] = 1
      #---------------똑같은 패턴의 반복...
      for j in range(N):
          if visit[j]:continue
          visit[j] = 1
          #if i == j : continue
          #---------------------------------
          for k in range(N):
              if visit[k]: continue # 앞에서 썼으면(1이면) 건너뜀
              visit[k] = 1
             # if k == i or k == j: continue
              print(i, j, k)
              visit[k] = 0
              # ----------------
         	visit[j] = 0
          #--------------------
     	 visit[i] = 0
      
      
  # 재귀 순열
  N = 3
  visit = [0] * N
  order = []
  def perm(k, n):
      if k == n:
          print(order)
          return
      for i in range(N):
          if visit[i]:continue
          visit[i] = 1
          order.append(i)
          perm(k + 1, n)
          order.pop()			# 재귀에서 order, visit 초기화시키는 방법임!!!
          visit[i] = 0
  ```

  

##  3. 조합(순서x)

- 앞에서 뽑은것 다음부터 뽑음...
- r개(뽑을 개수) 만큼 for문 중첩

```python
N = 5 # {0, 1, 2, 3, 4}
arr = 'ABCDE'
for i in range(0, N):
    for j in range(i + 1, N):
        for k in range(j + 1, N):
        	print(arr[i], arr[j], arr[k])
            
            
# 재귀 조합
N, R = 5, 3
choose = []
def comb(k, s): # 선택할 요소의 시작값
    if k == R:	# 모두 선택
        print(choose)
        return
    for i in range(s, N):
        choose.append(arr[i])
        comb(k + 1, i + 1)
        choose.pop()

comb(0, 0)

# 중복조합
for i in range(3):
    for j in range(i, 3):
        print(i, j)
```

