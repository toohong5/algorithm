# 큐(Queue)

## 1. 큐

### 1) 특성

- 선입선출구조(First In First Out)
- 뒤에서는 삽입만, 앞에서는 삭제만 이루어진다

### 2) 연산![1566955641398](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1566955641398.png)

### 3) 큐의 구현

- 크기 n의 1차원 배열

- 큐의 크기 = 배열의 크기

- front : 저장된 첫 번째 원소의 인덱스(비어있는 값을 가리킨다?)
- rear : 저장된 마지막 원소의 인덱스
- 초기상태 : font = rear = -1
- 공백상태 : front = rear
- 포화상태 : rear = n-1 (배열의 마지막 인덱스)
- 큐에서는 더하는 것만 가능

#### i) 삽입(enQueue)

#### ii) 삭제

- 큐에서 front가 가리키는 값을 리턴
- 비어있는지 확인을 먼저 해야함(비어있는 경우 메세지 출력)

#### iii) 공백/ 포화상태 검사

- 공백 : front == rear
- 포화 : rear = len(arr) - 1

#### iv) 검색

- 큐의 가장 앞에 있는 원소(front + 1 : front의 한자리 뒤에 있는 원소) 검색해서 반환
- front의 값 바꿔서는 안된다.
- front+1의 위치값을 읽어올 뿐임.



### 4) 원형 큐

- front = rear = 0
- front와 rear가 배열의 마지막 인덱스(n-1)을 가리킨 후 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함 -> mod 연산자 사용
- front 변수 : 공백 상태와 포화상태를 구분하기 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠

![1566958521269](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1566958521269.png)

- 삽입시, rear += 1 시켜준다
- 삭제시, front += 1
- front 자리는 항상 비워둔다
- 공백 : front = rear
- 포화 : (rear + 1) % len(cQ) == front => rear 한칸 뒤가 front이면 풀
- 삽입 : rear = (rear+1) % len(cQ) ; cQ[rear] = item
- 삭제 : front += 1 % len(cQ); return cQ[front] 

### 5) 연결 큐

- 큐의 원소 : 단순 연결 리스트의 노드
- 큐의 원소 순서 : 노드의 연결 순서, 링크로 연결되어 있음
- front : 첫 번째 노드를 가리키는 링크
- rear : 마지막 노드를 가리키는 링크
- 초기상태 : front = rear = null (메모리 주소)
- 공백상태 : front = rear = null
- 일단 a 노드를 우선 생성 -> b노드 생성 후-> a노드의 링크가 b를 가리키도록 한다.(연결됨)
- 메모리 절약할 수 있음
-  a노드 뒤의 링크부분에 b의 메모리주소를 적어줘 연결함
- 노드 : ㅁ->dataㅁ->link 

## 2. 우선순위 큐

- 배열, 리스트를 이용한 우선순위 큐
- 삽입 : 삽입된 원소를 우선순위에 맞는 위치에 삽입
- 삭제 : 우선순위가 가장 높은, 가장 앞에 있는 원소를 삭제
- 최대힙에서 삭제..
- 버퍼 : 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역

## 3. BFS(너비우선탐색)

- 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

## 4. 큐의 활용 : 버퍼

## 5. 최단경로

